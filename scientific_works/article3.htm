<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ПАРАЛЛЕЛЬНАЯ ОБРАБОТКА ТРАНЗАКЦИЙ В СИСТЕМАХ ИНТЕРНЕТ-ТОРГОВЛИ</title>
  <link rel="stylesheet" href="../css/style.css">
</head>
<body class="lynch-body">

<!-- Контент -->
<main class="container lynch-main">
  <!-- Кнопка назад -->
  <div class="article-button">
    <a href="index.htm" class="back-link">← Назад в библиотеку</a>
  </div>

  <!-- Статья -->
  <div class="individual-block">
    <p style="text-align: left;">УДК 004.75</p>
    <!-- Заголовок статьи -->
    <div class="article-title">
      <h1>
        ПАРАЛЛЕЛЬНАЯ ОБРАБОТКА ТРАНЗАКЦИЙ В СИСТЕМАХ ИНТЕРНЕТ-ТОРГОВЛИ С ИСПОЛЬЗОВАНИЕМ СОВРЕМЕННЫХ АРХИТЕКТУР БАЗ ДАННЫХ
      </h1>
      <p>
        <strong>Ястребов А.Р., Рычка О.В.</strong>
      </p>
    </div>

    <!-- Авторы и аффилиации -->
    <div class="article-author">
      <p>ФГБОУ ВО «Донецкий национальный технический университет» (г. Донецк)</p>
      <p>кафедра «Программная инженерия»</p>
      <p>e-mail: yastrebov_sasha98@mail.ru, olga_rychka@mail.ru</p>
    </div>

    <!-- Аннотация -->
    <div class="article-annotation">
      <h3>Аннотация</h3>
      <p>
        <strong>Ястребов А.Р., Рычка О.В. Параллельная обработка транзакций в системах интернет-торговли с использованием современных архитектур баз данных. В статье представлено экспериментальное исследование производительности четырех современных систем управления базами данных --- PostgreSQL, MySQL, MariaDB и Firebird --- в контексте обработки параллельных транзакций в системах интернет-торговли.</strong>
      </p>
      <p><strong>Ключевые слова:</strong> параллельная обработка, СУБД, уровни изоляции, пакетная обработка, системы интернет-торговли.</p>
    </div>

    <!-- Содержание статьи -->
    <div class="article-content">
      <!-- Основной текст статьи -->
      <h2>Введение</h2>
      <p>Рост интернет-торговли ведет к увеличению числа параллельных транзакций, что создает риск конфликтов, блокировок и падения производительности в СУБД. Поиск баланса между надежностью и скоростью обработки транзакций является критически важной задачей для масштабируемости современных систем. Цель настоящей работы --- провести экспериментальное сравнение четырёх современных систем управления базами данных --- PostgreSQL, MySQL, MariaDB и Firebird --- с точки зрения их способности эффективно обрабатывать параллельные транзакции в условиях, моделирующих реальные сценарии интернет-торговли. Задачами исследования являются анализ влияния архитектуры СУБД и уровня изоляции транзакций на производительность, а также определение оптимальных конфигураций, обеспечивающих баланс между скоростью обработки и надёжностью данных.</p>

      <h2>1 Теоретические основы параллельной обработки транзакций</h2>
      <p>Основу параллельной обработки составляет транзакция --- последовательность операций с базой данных, которые выполняются как единое целое, через атомарность, согласованность, изоляцию и долговечность [<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">1</a>]. Данные свойства реализованы во всех ведущих реляционных СУБД, что обеспечивает высокую степень надёжности корпоративных информационных систем.</p>
      <p>Уровни изоляции (Read Uncommitted, Read Committed, Repeatable Read, Serializable) определяют, как транзакции могут взаимодействовать между собой, и насколько сильно могут пересекаться и мешать друг другу при параллельной работе. Современные СУБД развивают параллелизм через многопоточность, распределённые транзакции и батчевую обработку. Механизмы вроде многоверсионности и предикативных блокировок минимизируют конфликты и распределяют нагрузку.</p>
      <p>В интернет-торговле, где параллельно выполняются заказы, обновления остатков и платежи, корректные уровни изоляции и архитектурные решения СУБД предотвращают конфликты и потери данных, обеспечивая отказоустойчивость и производительность при высокой нагрузке.</p>

      <h2>2 Методология исследования</h2>
      <p>Для исследования использовались четыре СУБД --- PostgreSQL, MySQL, MariaDB и Firebird, каждая с различными механизмами параллелизма. PostgreSQL применяет MVCC, MySQL --- блокировки InnoDB [<a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-transaction-isolation-levels.html">2</a>], MariaDB --- parallel replication, Firebird --- многопоколенную архитектуру [<a href="https://www.firebirdsql.org/file/documentation/html/en/firebirddocs/ufb/using-firebird.html">3</a>]. Эксперименты проводились на ноутбуке с ОС Windows 10, процессором AMD Ryzen 5 3500U (2.1 ГГц) и 8 ГБ ОЗУ. Для тестирования использовалась унифицированная база данных с таблицами users, products и orders, моделирующая структуру интернет-магазина. Это обеспечило сопоставимость результатов при анализе производительности различных систем.</p>
      <p>Было подготовлено четыре скрипта для трёх типов исследований: 1) оценка масштабируемости СУБД путём измерения производительности при росте числа параллельных транзакций; 2) анализ компромисса между согласованностью данных и скоростью работы при разных уровнях изоляции; 3) исследование влияния размера пакета операций на время отклика и количество успешно выполненных транзакций.</p>
      <p>Параметры исследований включали варьирование количества параллельных транзакций, изменение уровня изоляции и размера пакета. Для оценки эффективности использовались ключевые метрики: время обработки транзакций, число успешно завершённых транзакций и задержка выполнения.</p>

      <h2>3 Результаты экспериментов</h2>
      
      <h3>3.1 Производительность при увеличении числа параллельных транзакций</h3>
      <p>Для оценки масштабируемости и способности СУБД эффективно обрабатывать параллельные транзакции было проведено экспериментальное исследование с использованием Python-скрипта, который имитировал выполнение типичных операций интернет-магазина: добавление нового пользователя, оформление заказа и обновление остатка товара. Для каждой СУБД были заданы одинаковые сценарии, различавшиеся только уровнем параллелизма. Количество потоков (1, 5, 10, 20 и 50) соответствовало числу одновременно выполняемых транзакций. Каждая транзакция включала три основные операции записи в базу данных, выполнявшиеся в рамках одной логической сессии с управлением соединениями через пул.</p>
      <p>PostgreSQL показала плавный рост времени отклика и 100% успешность транзакций благодаря эффективной реализации многоверсионного контроля (MVCC), что подтверждает её стабильность и хорошую масштабируемость.</p>

      <table border="1">
        <caption>Таблица 1. Исследование производительности для PostgreSQL</caption>
        <tr>
          <th>Потоки</th>
          <th>Среднее время (мс)</th>
          <th>Успехов</th>
          <th>Ошибок</th>
          <th>Общее время (с)</th>
        </tr>
        <tr>
          <td>1</td>
          <td>15.63</td>
          <td>1</td>
          <td>0</td>
          <td>0.016</td>
        </tr>
        <tr>
          <td>5</td>
          <td>3.13</td>
          <td>5</td>
          <td>0</td>
          <td>0.485</td>
        </tr>
        <tr>
          <td>10</td>
          <td>4.69</td>
          <td>10</td>
          <td>0</td>
          <td>1.172</td>
        </tr>
        <tr>
          <td>20</td>
          <td>5.35</td>
          <td>20</td>
          <td>0</td>
          <td>2.476</td>
        </tr>
        <tr>
          <td>50</td>
          <td>6.82</td>
          <td>50</td>
          <td>0</td>
          <td>6.862</td>
        </tr>
      </table>

      <p>MySQL демонстрировала умеренный рост производительности до 20 потоков, но при 50 транзакциях возникли ошибки фиксации (7 из 50), что связано с блокировками (gap locks, next-key locks) в InnoDB. Несмотря на относительно высокую скорость обработки при малом числе потоков, при увеличении нагрузки система столкнулась с внутренними конфликтами транзакций.</p>

      <table border="1">
        <caption>Таблица 2. Исследование производительности для MySQL</caption>
        <tr>
          <th>Потоки</th>
          <th>Среднее время (мс)</th>
          <th>Успехов</th>
          <th>Ошибок</th>
          <th>Общее время (с)</th>
        </tr>
        <tr>
          <td>1</td>
          <td>26.25</td>
          <td>1</td>
          <td>0</td>
          <td>0.026</td>
        </tr>
        <tr>
          <td>5</td>
          <td>15.63</td>
          <td>5</td>
          <td>0</td>
          <td>0.016</td>
        </tr>
        <tr>
          <td>10</td>
          <td>13.07</td>
          <td>10</td>
          <td>0</td>
          <td>0.027</td>
        </tr>
        <tr>
          <td>20</td>
          <td>13.28</td>
          <td>20</td>
          <td>0</td>
          <td>0.031</td>
        </tr>
        <tr>
          <td>50</td>
          <td>16.07</td>
          <td>43</td>
          <td>7</td>
          <td>0.053</td>
        </tr>
      </table>

      <p>MariaDB показала наилучшие результаты при средних нагрузках (5--20 потоков) с минимальным временем выполнения и незначительным числом ошибок, что обусловлено эффективным распределением нагрузки и parallel replication.</p>

      <table border="1">
        <caption>Таблица 3. Исследование производительности для MariaDB</caption>
        <tr>
          <th>Потоки</th>
          <th>Среднее время (мс)</th>
          <th>Успехов</th>
          <th>Ошибок</th>
          <th>Общее время (с)</th>
        </tr>
        <tr>
          <td>1</td>
          <td>14.15</td>
          <td>1</td>
          <td>0</td>
          <td>0.014</td>
        </tr>
        <tr>
          <td>5</td>
          <td>0.00</td>
          <td>5</td>
          <td>0</td>
          <td>0.016</td>
        </tr>
        <tr>
          <td>10</td>
          <td>0.00</td>
          <td>10</td>
          <td>0</td>
          <td>0.016</td>
        </tr>
        <tr>
          <td>20</td>
          <td>7.89</td>
          <td>19</td>
          <td>1</td>
          <td>0.024</td>
        </tr>
        <tr>
          <td>50</td>
          <td>4.69</td>
          <td>49</td>
          <td>1</td>
          <td>0.047</td>
        </tr>
      </table>

      <p>Firebird продемонстрировала худшую производительность с резким ростом времени выполнения, хотя и сохранила 100% успешность транзакций. Это объясняется накладными расходами многопоколенной архитектуры (MGA) на управление версиями данных.</p>

      <table border="1">
        <caption>Таблица 4. Исследование производительности для Firebird</caption>
        <tr>
          <th>Потоки</th>
          <th>Среднее время (мс)</th>
          <th>Успехов</th>
          <th>Ошибок</th>
          <th>Общее время (с)</th>
        </tr>
        <tr>
          <td>1</td>
          <td>17.68</td>
          <td>1</td>
          <td>0</td>
          <td>0.116</td>
        </tr>
        <tr>
          <td>5</td>
          <td>73.47</td>
          <td>5</td>
          <td>0</td>
          <td>0.188</td>
        </tr>
        <tr>
          <td>10</td>
          <td>65.05</td>
          <td>10</td>
          <td>0</td>
          <td>0.184</td>
        </tr>
        <tr>
          <td>20</td>
          <td>129.06</td>
          <td>20</td>
          <td>0</td>
          <td>0.296</td>
        </tr>
        <tr>
          <td>50</td>
          <td>286.06</td>
          <td>50</td>
          <td>0</td>
          <td>0.740</td>
        </tr>
      </table>

      <p>На основании полученных данных можно заключить, что лучшую масштабируемость при росте числа параллельных транзакций показали PostgreSQL и MariaDB, которые эффективно реализуют многоверсионный контроль и оптимизированное распределение потоков. MySQL сохранила приемлемый уровень производительности, но столкнулась с блокировками при высокой нагрузке. Firebird продемонстрировала устойчивость к ошибкам, но при этом существенно потеряла в скорости обработки из-за особенностей своей архитектуры.</p>

      <h3>3.2 Влияние уровня изоляции транзакций</h3>
      <p>Для анализа влияния уровня изоляции на производительность транзакционной обработки были проведены тесты для трёх стандартных уровней --- READ COMMITTED, REPEATABLE READ и SERIALIZABLE. Эксперименты имитировали одновременное выполнение множества операций вставки заказов в базу данных интернет-магазина, где 10 потоков выполняли по 50 транзакций. Скрипт, динамически изменял уровень изоляции для каждого теста, чтобы оценить влияние этого параметра на общую скорость выполнения и стабильность фиксации транзакций.</p>

      <table border="1">
        <caption>Таблица 5. Исследование влияния уровней изоляции транзакций</caption>
        <tr>
          <th>Уровень изоляции</th>
          <th>PostgreSQL (время, успешные / ошибки)</th>
          <th>MySQL (время, успешные / ошибки)</th>
          <th>MariaDB (время, успешные / ошибки)</th>
          <th>Firebird (время, успешные / ошибки)</th>
        </tr>
        <tr>
          <td>READ COMMITTED</td>
          <td>1.11 с --- 500 / 0</td>
          <td>0.70 с --- 500 / 0</td>
          <td>0.26 с --- 462 / 38</td>
          <td>2.51 с --- 500 / 0</td>
        </tr>
        <tr>
          <td>REPEATABLE READ</td>
          <td>1.23 с --- 500 / 0</td>
          <td>0.55 с --- 500 / 0</td>
          <td>0.24 с --- 450 / 50</td>
          <td>2.03 с --- 500 / 0</td>
        </tr>
        <tr>
          <td>SERIALIZABLE</td>
          <td>1.20 с --- 500 / 0</td>
          <td>0.53 с --- 500 / 0</td>
          <td>0.24 с --- 452 / 48</td>
          <td>1.97 с --- 500 / 0</td>
        </tr>
      </table>

      <p>Изменение уровня изоляции по-разному влияло на СУБД. PostgreSQL и Firebird обеспечили 100% успешность, MySQL и MariaDB --- максимальную скорость при лёгком снижении стабильности. Оптимум между скоростью и надёжностью достигается на уровне Read Committed для MySQL и Repeatable Read для PostgreSQL.</p>

      <h3>3.3 Влияние размера пакета транзакций</h3>
      <p>В каждом тесте выполнялась вставка 1000 заказов в таблицу orders с варьированием параметра batch size --- количества операций, объединённых в одну транзакцию. Используемый скрипт открывал соединение с базой данных, последовательно выполнял пакеты вставок и фиксировал результаты (время выполнения и среднюю загрузку процессора). Таким образом моделировались реальные сценарии интернет-торговли, где группы заказов могут обрабатываться пакетно, например при массовом оформлении покупок или синхронизации данных между сервисами.</p>

      <table border="1">
        <caption>Таблица 6. Исследование влияния размера пакета транзакций</caption>
        <tr>
          <th>Batch size</th>
          <th>PostgreSQL (время / CPU %)</th>
          <th>MySQL (время / CPU %)</th>
          <th>MariaDB (время / CPU %)</th>
          <th>Firebird (время / CPU %)</th>
        </tr>
        <tr>
          <td>1</td>
          <td>0.48 с / 3.3 %</td>
          <td>6.44 с / 5.5 %</td>
          <td>2.56 с / 2.2 %</td>
          <td>2.56 с / 2.2 %</td>
        </tr>
        <tr>
          <td>10</td>
          <td>0.22 с / 10.7 %</td>
          <td>0.94 с / 7.9 %</td>
          <td>0.42 с / 5.9 %</td>
          <td>0.42 с / 5.9 %</td>
        </tr>
        <tr>
          <td>100</td>
          <td>0.17 с / 10.9 %</td>
          <td>0.38 с / 16.5 %</td>
          <td>0.17 с / 8.6 %</td>
          <td>0.17 с / 8.6 %</td>
        </tr>
      </table>

      <p>Для PostgreSQL время выполнения снизилось с 0.48 с (batch=1) до 0.17 с (batch=100) при незначительном росте нагрузки на CPU, что подтверждает эффективность буферизации в MVCC. Для сценариев интернет-торговли оптимальным значением можно считать batch = 50--100, обеспечивающим баланс между скоростью и умеренной нагрузкой на процессор.</p>
      <p>MySQL продемонстрировала значительный прирост производительности при увеличении batch size: время сократилось с 6.44 с при batch = 1 до 0.38 с при batch = 100. Это объясняется тем, что InnoDB при каждой фиксации выполняет запись в журнал и синхронизацию данных на диск; при увеличении размера пакета эти накладные расходы распределяются на большее число операций. Повышение загрузки CPU с 5.5 % до 16.5 % указывает на более активное использование буфера и улучшение пропускной способности. Таким образом, MySQL выигрывает от крупных пакетов транзакций, особенно при вставках большого объёма данных.</p>
      <p>MariaDB показала результат, аналогичный PostgreSQL (0.17 с при batch=100), с 15-кратным ускорением по сравнению с одиночными вставками.</p>
      <p>Firebird, согласно представленным данным, продемонстрировала схожую с MariaDB динамику (с 2.56 с до 0.17 с), так как крупные пакеты уменьшают частоту операций фиксации, затратных в MGA-архитектуре.</p>
      <p>Эксперимент подтвердил, что увеличение размера пакета транзакций значительно повышает производительность всех исследуемых СУБД. Наибольший прирост эффективности наблюдается в MySQL и MariaDB, где использование крупных пакетов сокращает время выполнения более чем в 10 раз. PostgreSQL демонстрирует стабильное улучшение производительности при минимальной нагрузке на процессор, а Firebird показывает аналогичную MariaDB зависимость от частоты фиксаций транзакций. Для систем интернет-торговли с групповой обработкой заказов оптимальным является использование размера пакета от 50 до 100 операций, что обеспечивает максимальную пропускную способность при минимальных накладных расходах.</p>

      <h2>Выводы</h2>
      <p>В работе рассмотрены теоретические и практические аспекты параллельной обработки транзакций в системах интернет-торговли с использованием современных архитектур баз данных. Проведённые эксперименты показали, что наиболее стабильные и масштабируемые результаты продемонстрировали PostgreSQL и MariaDB благодаря эффективной реализации многоверсионного контроля и оптимизации параллельных операций. MySQL обеспечила высокую скорость обработки при умеренной нагрузке, однако при большом числе одновременных транзакций наблюдались блокировки. Firebird сохранила полную надёжность выполнения, но уступила по производительности из-за особенностей своей многопоколенной архитектуры.</p>
      <p>Увеличение размера пакета транзакций позволило всем системам существенно сократить время обработки, что подтверждает важность оптимизации групповых операций при проектировании высоконагруженных сервисов. Полученные результаты подтверждают актуальность выбора архитектуры и параметров СУБД как ключевого фактора устойчивости и эффективности современных систем интернет-торговли [<a href="https://dl.acm.org/doi/10.1145/1620585.1620587">5</a>].</p>

      <h2>Литература</h2>
      <ol>
        <li>Gray, J. The Transaction Concept: Virtues and Limitations [Электронный ресурс] / Jim Gray // Microsoft Research. -- 1995. -- Режим доступа: <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf</a></li>
        <li>MySQL 8.4 Reference Manual. InnoDB Transaction Isolation Levels [Электронный ресурс] / Oracle Corporation. -- 2024. -- Режим доступа: <a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-transaction-isolation-levels.html">https://dev.mysql.com/doc/refman/8.4/en/innodb-transaction-isolation-levels.html</a></li>
        <li>Firebird Documentation: Using Firebird [Электронный ресурс] / FirebirdSQL Foundation. -- 2023. -- Режим доступа: <a href="https://www.firebirdsql.org/file/documentation/html/en/firebirddocs/ufb/using-firebird.html">https://www.firebirdsql.org/file/documentation/html/en/firebirddocs/ufb/using-firebird.html</a></li>
        <li>TPC Benchmark™ C Standard Specification [Электронный ресурс] / Transaction Processing Performance Council (TPC). -- Version 5.11.0. -- 2023. -- Режим доступа: <a href="https://www.tpc.org/tpc_documents_current_versions/pdf/tpc-c_v5.11.0.pdf">https://www.tpc.org/tpc_documents_current_versions/pdf/tpc-c_v5.11.0.pdf</a></li>
        <li>Harizopoulos, S. OLTP Through the Looking Glass, and What We Found There [Электронный ресурс] / Stavros Harizopoulos, Daniel J. Abadi, Samuel Madden, Michael Stonebraker // Proceedings of the ACM SIGMOD. -- 2008. -- Режим доступа: <a href="https://dl.acm.org/doi/10.1145/1620585.1620587">https://dl.acm.org/doi/10.1145/1620585.1620587</a></li>
      </ol>
      
      <!-- Английская версия аннотации -->
      <div class="article-annotation">
        <p><strong>Yastrebov A.R., Rychka O.V. Parallel processing of transactions in online retail systems using modern database architectures. The article presents an experimental study of the performance of four modern database management systems --- PostgreSQL, MySQL, MariaDB, and Firebird --- in the context of processing parallel transactions in online retail systems.</strong></p>
        <p><strong>Key words:</strong> parallel processing, database management systems, isolation levels, batch processing, online retail systems.</p>
      </div>
    </div>
  </div>
</main>

<!-- Подвал -->
<footer class="footer lynch-footer">
  <div class="container">
    <nav class="bottom-menu">
      <a href="../diss/index.html">Реферат</a>
      <a href="../science.html">Научные труды</a>
      <a href="../ind/index.html">Индивидуальный раздел</a>
    </nav>
  </div>
</footer>

<!-- Кнопка наверх -->
<button id="toTop">↑</button>

<script>
  const toTop = document.getElementById("toTop");
  window.addEventListener("scroll", () => {
    if (window.scrollY > 300) {
      toTop.classList.add("show");
    } else {
      toTop.classList.remove("show");
    }
  });
  toTop.addEventListener("click", () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
  });
</script>
</body>
</html>