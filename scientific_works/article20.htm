<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Шардинг с помощью хэш-партиционирования</title>
  <link rel="stylesheet" href="../css/style.css">
</head>
<body class="lynch-body">

<!-- Контент -->
<main class="container lynch-main">
  <!-- Кнопка назад -->
  <div class="article-button">
    <a href="index.htm" class="back-link">← Назад в библиотеку</a>
  </div>

  <!-- Статья -->
  <div class="individual-block">
    <!-- Заголовок статьи -->
    <div class="article-title">
      <h1>
        Шардинг с помощью хэш-партиционирования
      </h1>
      <h2><i>Шаблон масштабируемости базы данных для достижения равномерного распределения кластеров базы данных</i></h2>
    </div>

    <!-- Авторы и аффилиации -->
    <div class="article-author">
      <p>
        <strong>Кайо Х. Коста</strong>
      </p>
      <p>Universidade Estadual do Ceara, Форталеза, Бразилия.</p>
    </div>
    <div class="article-author">
      <p>
        <strong>Жоау Вианни Б.М. Фильо</strong>
      </p>
      <p>Universidade Estadual do Ceara, Форталеза, Бразилия.</p>
    </div>
    <div class="article-author">
      <p>
        <strong>Пауло Энрике М. Майя</strong>
      </p>
      <p>Universidade Estadual do Ceara, Форталеза, Бразилия.</p>
    </div>

    <!-- Аннотация -->
    <div class="article-annotation">
      <h3>Аннотация</h3>
      <p><strong>С началом XXI века требования к масштабированию веб-приложений резко возросли. Такие приложения, как социальные сети, электронная коммерция и медиахостинг, начали генерировать большой трафик данных, и компании начали отслеживать эти ценные данные. Системы баз данных, ответственные за хранение всей этой информации, должны были масштабироваться, чтобы справиться с огромной нагрузкой. С появлением облачных вычислений горизонтальное масштабирование системы базы данных стало доступным решением, сделав шардинг данных жизнеспособным вариантом масштабирования. Но чтобы получить выгоду от шардинга данных, проектировщикам баз данных необходимо определить наилучший способ распределения данных между узлами общего кластера. В данной статье рассматриваются модели распределения шардинга базы данных, в частности, метод, известный как хэш-партиционирование. Наша цель — каталогизировать в формате шаблона масштабируемости базы данных передовой опыт, заключающийся в шардинге данных между узлами кластера базы данных с использованием метода хэш-партиционирования для эффективной балансировки нагрузки между серверами баз данных. Таким образом, мы намерены сделать сопоставление сценария и его решения общедоступным, помогая разработчикам определить, когда следует применять шаблон вместо других методов сегментирования.</strong></p>
      <p><strong>Ключевые слова:</strong> шардинг базы данных, хэш-партиционирование, шаблон, масштабируемость.</p>
    </div>

    <!-- Содержание статьи -->
    <div class="article-content">
      <!-- Основной текст статьи -->
      <h2>1 ВВЕДЕНИЕ</h2>
      <p>С началом XXI века требования к веб-приложениям значительно возросли. Технологии Web 2.0 сделали веб-приложения гораздо более привлекательными благодаря улучшению их интерактивности. Появился целый ряд новых приложений: например, социальные сети, приложения для обмена мультимедиа и онлайн-офисные пакеты. Эти новые приложения привлекли огромное количество пользователей, многие из которых перешли с локальных приложений на онлайн-приложения. Одновременно многие компании разработали приложения на основе SOA, упрощающие интеграцию между различными системами и расширяющие повторное использование функций через сервисы. В этом сценарии были разработаны новые функции интеграции, и приложения начали обмениваться большими объемами данных.</p>
      <p>Объём данных, подлежащих хранению и управлению, рос пропорционально росту трафика в этой новой среде. Сегодня крупным сайтам электронной коммерции приходится управлять данными тысяч одновременных активных сеансов. Социальные сети регистрируют действия своих пользователей для последующего анализа с помощью рекомендуемых систем. Онлайн-приложения хранят предпочтения миллионов пользователей. Чтобы справиться с ростом объёма данных и трафика, потребовались дополнительные вычислительные ресурсы. Следовательно, базы данных, ответственные за хранение всей этой информации, должны были масштабироваться, чтобы справляться с огромной нагрузкой без ущерба для производительности сервисов и приложений.</p>
      <p>Системы баз данных могут масштабироваться как вертикально, так и горизонтально. Вертикальное масштабирование подразумевает использование более мощных машин, большего количества процессоров, дискового пространства и памяти. Вертикальное масштабирование сервера баз данных не всегда возможно из-за высокой стоимости приобретения всех этих ресурсов, а также физических и практических ограничений. Альтернативой является вертикальное масштабирование системы баз данных, которое заключается в объединении нескольких небольших машин в кластер (Сэдэлидж и Фаулер, 2013). Для увеличения емкости кластера по запросу добавляется стандартное оборудование. Относительно новая, но быстро получившая распространение технология облачных вычислений сделала необходимую инфраструктуру для горизонтального масштабирования систем более доступной.</p>
      <p>После того, как база данных будет иметь необходимую инфраструктуру для работы в большом кластере, необходимо выбрать модель распределения, основанную на требованиях приложения. Приложению может потребоваться масштабируемость чтения, записи или и то, и другое. По сути, существует две модели распределения: репликация и шардинг. Первая модель копирует одни и те же данные на несколько узлов, а вторая размещает разные данные на разных узлах (Sadalage and Fowler, 2013). Оба подхода ортогональны и могут использоваться совместно.</p>

      <div class="article-picture">
        <img src="images/ar20_1.webp" style="max-width:40%;">
        <p>Рисунок 1 - Четыре стратегии разбиения: (a) циклический перебор, (b) диапазон, (c) список и (d) хеш (DeWitt и Gray, 1992).</p>
      </div>

      <p>В данной статье рассматриваются модели распределения шардинга баз данных, в частности, метод, известный как хэш-партиционирование. Целью данной работы является каталогизация в формате шаблона масштабируемости баз данных (Database Scalability Pattern) наилучшей практики, заключающейся в шардинге данных между узлами кластера баз данных с использованием техники хэш-партиционирования для оптимальной балансировки нагрузки между серверами баз данных. Этот шаблон позволяет избежать создания «горячих точек», то есть областей данных, в которых операции чтения и записи сосредоточены в одном узле или группе узлов. Этот метод шардинга встроен в некоторые NoSQL-базы данных, такие как AmazonDB (DeCandia et al., 2007) и MongoDB (Boicea et al., 2012), а также в фреймворки ORM для реляционных баз данных, например, EclipseLink (Kalotra and Kaur, 2014) и Hibernate Shards (Wu and Yin, 2010). Наш главный вклад заключается в том, чтобы сделать общедоступной сопоставление сценария и его решения, помогая разработчикам определять, когда следует применять хэш-разбиение в сегментированных кластерах вместо других методов сегментирования.</p>
      <p>Остальная часть статьи структурирована следующим образом. В разделе 2 представлена ​​предыстория, а в разделе 3 обсуждаются основные работы, связанные с данной темой. В разделе 4 модель описана с использованием формата, предложенного Хопе и Б. Вульфом (Hohpe and B.Woolf, 2003), который используется для обозначения подразделов модели. Наконец, в разделе 5 представлены выводы и дальнейшие исследования.</p>

      <h2>2 ИСТОРИЯ</h2>

      <p>По мере роста трафика и объёма данных масштабирование сервера базы данных становится всё сложнее и дороже. Более привлекательным вариантом является горизонтальное масштабирование, то есть размещение базы данных на кластере серверов, где запросы могут обрабатываться несколькими узлами. При распределённой архитектуре базы данных нагрузка распределяется между серверами, составляющими кластер, что повышает производительность и доступность системы. Существует два подхода к горизонтальному масштабированию системы базы данных: распределённые системы баз данных и параллельные системы баз данных. Оба подхода используются в высокопроизводительных вычислениях, где требуется многопроцессорная архитектура для обработки больших объёмов данных и трафика.</p>
      <p>В работе Элмасри и Навате (Elmasri and Navathe, 2011) распределенные системы баз данных определяются как совокупность нескольких логически взаимосвязанных баз данных, распределенных по компьютерной сети, а распределенная система управления базами данных (РСУБД) — как программная система, которая управляет распределенной базой данных, делая распределение прозрачным для пользователя. В этой архитектуре отсутствуют общие аппаратные ресурсы, и узлы могут иметь разные аппаратные конфигурации. Параллельные системы управления базами данных объединяют несколько меньших машин для достижения той же пропускной способности, что и одна большая машина, часто с большей масштабируемостью и надежностью, чем однопроцессорная система управления базами данных (Connolly and Begg, 2005). Однако несколько процессоров используют либо общую память (дисковое хранилище и основную память), либо только дисковую память (в этом случае каждый процессор имеет свою собственную основную память).</p>
      <p>Многие поставщики баз данных предлагают решения для масштабирования, основанные на подходе с общим диском, например, Oracle RAC (Abramson et al., 2009). Такие решения связывают несколько серверов высокоскоростной сетью, но у них всё равно есть ограничивающее устройство. Они используют общее устройство хранения данных, которое является узким местом системы. В параллельной архитектуре без общего доступа процессоры взаимодействуют через высокоскоростную сеть, и у каждого из них есть своя основная и вторичная память. Такой тип архитектуры требует симметрии узлов и однородности, но в полностью распределённой базе данных однородность системы не требуется. Для достижения настоящей горизонтальной масштабируемости необходимо использовать архитектуру полностью распределённой системы баз данных.</p>

      <h3>2.1 Модели распределения</h3>

      <p>После того, как аппаратные ресурсы (серверные узлы) станут доступны для развертывания распределенной базы данных, следует выбрать модель распределения, которая позволит максимально эффективно использовать возможности кластера. Грубо говоря, существует два способа распределения данных: репликация и шардинг.</p>

      <h4>2.1.1 Репликация</h4>

      <p>Репликация может выполняться двумя способами: ведущий-ведомый и одноранговый. В схеме ведущий-ведомый один узел отвечает за обработку любых обновлений данных, а фоновый процесс отвечает за синхронизацию данных между остальными узлами, ведомыми. Такой тип репликации рекомендуется для приложений, интенсивно читающих данные. Для увеличения производительности кластера по обработке запросов на чтение можно добавить больше ведомых узлов. Однако пропускная способность записи ограничена производительностью ведущего узла по обработке запросов на запись. В одноранговой репликации ведущий узел отсутствует. Все реплики могут принимать запросы на запись, тем самым повышая производительность системы по обработке запросов на запись. С другой стороны, одноранговым кластерам репликации приходится сталкиваться с проблемами несогласованности, которые могут возникнуть.</p>

      <h4>2.1.2 Шардинг</h4>

      <p>Шардинг — это способ горизонтального масштабирования базы данных посредством горизонтальной фрагментации. Горизонтальный фрагмент отношения (таблицы) представляет собой подмножество кортежей в этом отношении. Кортежи, принадлежащие горизонтальному фрагменту, определяются условием для одного или нескольких атрибутов отношения (Elmasri and Navathe, 2011). Часто используется только один атрибут. То есть горизонтальная масштабируемость поддерживается размещением различных частей данных на разных серверах кластера. Цель состоит в том, чтобы разные клиенты взаимодействовали с разными узлами сервера. Следовательно, нагрузка равномерно распределяется между серверами. Шардинг особенно ценен для производительности, поскольку он может повысить производительность как чтения, так и записи. Репликация может значительно повысить производительность чтения, но малоэффективна для приложений, выполняющих несколько операций записи. Шардинг обеспечивает горизонтальное масштабирование этих операций.</p>

      <h4>2.1.3 Стратегии разбиения (партицирования)</h4>

      <p>Существует четыре различных стратегии разбиения данных в кластере: циклическое разбиение, разбиение по диапазону, разбиение по списку и разбиение по хэшу (DeWitt and Gray, 1992). Простейшей стратегией разбиения является циклическое разбиение, при котором строки таблицы распределяются между узлами циклически (рис. 1a).</p>
      <p>Для стратегий разбиения по диапазону, разбиения по списку и разбиения по хэшу необходимо выбрать атрибут, называемый ключом разбиения, среди атрибутов таблицы. Разбиение строк таблицы будет основано на значении ключа разбиения. В стратегии разбиения по диапазону разбиению назначается заданный диапазон значений. Данные распределяются между узлами таким образом, что каждая разбиение содержит строки, для которых значение ключа разбиения находится в пределах этого диапазона (рис. 1b).</p>
      <p>Списочная стратегия аналогична стратегии разбиения по диапазону. В первой разбиение имеет список значений, назначенных по одному. Раздел выбирается для сохранения строки, если значение ключа разбиения равно одному из значений, определённых в списке (рис. 1c). В последнем случае сопоставление значений ключа разбиения с соответствующими узлами осуществляется на основе результата хэш-функции. Значение ключа разбиения используется в качестве параметра хэш-функции, а результат определяет место размещения данных (рис. 1d).</p>

      <h2>3 СОПУТСТВУЮЩИЕ РАБОТЫ</h2>

      <p>Каталог шаблонов проектирования программного обеспечения был впервые описан Гаммой и др. (Gamma et al., 1994), пионером в области компьютерных наук. Впоследствии Фаулер и др. (Fowler et al., 2002) и Хопе и Б. Вульф (Hohpe and B.Woolf, 2003) выявили и опубликовали архитектурные шаблоны проектирования программного обеспечения.</p>
      <p>Шумахер и др. (Shumacher et al., 2006) представляют в формате шаблонов набор передовых практик для повышения безопасности приложений на разных уровнях. Хафиз (Hafiz, 2006) описывает четыре шаблона проектирования, применимых к проектированию систем анонимности и которые могут быть использованы для защиты конфиденциальных данных. Шумахер (Shumacher, 2003) представляет подход к извлечению шаблонов безопасности из стандартов безопасности и представляет два шаблона для анонимности и конфиденциальности. Штраух и др. (Strauch et al., 2012) описывают четыре шаблона, обеспечивающих конфиденциальность данных в облаке.</p>
      <p>Авторы (Eessaar, 2008) предлагают подход к проектированию и реализации баз данных на основе шаблонов, который способствует использованию шаблонов в качестве основы для генерации кода. Кроме того, они представляют программную систему, которая генерирует код на основе шаблонов проектирования баз данных. Однако в их работе не перечислены шаблоны проектирования баз данных, на которых основан предлагаемый инструмент, и не упоминаются шаблоны проектирования, относящиеся к распределенным системам баз данных.</p>

      <table border="1">
        <caption>Таблица 2. Распространенные ключи хэширования разбиения и их эффективность</caption>
        <tr>
          <th>Хэш-ключ</th>
          <th>Эффективность</th>
        </tr>
        <tr>
          <td>Идентификатор пользователя в приложениях с большим количеством пользователей</td>
          <td>Хорошо</td>
        </tr>
        <tr>
          <td>Код состояния в приложениях с небольшим количеством возможных кодов состояния. </td>
          <td>Плохо</td>
        </tr>
        <tr>
          <td>Идентификатор отслеживаемого устройства, который сохраняет данные с относительно одинаковыми интервалами. </td>
          <td>Хорошо</td>
        </tr>
        <tr>
          <td>Идентификатор отслеживаемого устройства, где один из них гораздо популярнее всех остальных</td>
          <td>Плохо</td>
        </tr>
      </table>

      <p>В статье (Фелинг и др., 2011) предлагается подход на основе шаблонов для снижения сложности архитектуры облачных приложений. Разработанный язык шаблонов призван помочь разработчикам в определении облачных сред и архитектурных шаблонов, применимых к их задачам. Фелинг и др. (Фелинг и др., 2011) также дают обзор ранее обнаруженных шаблонов. В этом списке шесть шаблонов, связанных с облачным хранением данных, но ни один из них не связан с методами сегментирования данных.</p>
      <p>Паллман (Паллман, 2011) представляет набор шаблонов, реализованных в облачной платформе Microsoft Azure, и описывает пять шаблонов хранения данных, которые могут быть использованы для хранения данных, ориентированных на записи. В статье (Го, 2014) шаблон «Ключ раздела» описывает распределение данных в Azure на высоком уровне, не определяя стратегию, используемую для фактического разделения данных. Шаблон, описанный в нашей статье, фокусируется на стратегии, используемой для распределения данных, и не ориентирован на платформу какого-либо поставщика.</p>
      <p>В техническом документе (Adler, 2011) предлагается эталонная архитектура и рекомендации по запуску масштабируемых приложений в облаке. Предлагаемые рекомендации, не организованные в виде шаблонов, основаны на обширном опыте, накопленном в ходе изучения множества различных отраслевых сценариев. Хотя Адлер (Adler, 2011) и рассматривает масштабируемость баз данных, он рассматривает только репликацию типа «главный-подчинённый».</p>
      <p>Стоунбрейкер и Кэттел (Stonebraker and Cattell, 2011) предлагают десять правил для достижения масштабируемости в хранилищах данных, обрабатывающих простые операции. В ходе обсуждения этих правил авторы указывают на важные недостатки шардинга данных в конкретных ситуациях. Наблюдения Стоунбрейкера и Кэттела (Stonebraker and Cattell, 2011) сыграли важную роль в построении шаблона, представленного в данной работе.</p>
      <p>В дополнение к четырём шаблонам конфиденциальности, Штраух и др. (Strauch et al., 2012) также предлагают два шаблона, связанных с горизонтальной масштабируемостью уровня доступа к данным приложения: «Локальный прокси-сервер базы данных» и «Локальный маршрутизатор на основе шардинга». Шаблон «Локальный маршрутизатор на основе шардинга» предполагает расширение уровня доступа к данным за счёт добавления маршрутизатора, отвечающего за распределение запросов на чтение и запись между серверами баз данных. Каждый сервер баз данных в кластере хранит часть данных, разделенных с использованием той или иной техники шардинга. Тем не менее, этот шаблон не предполагает какой-либо конкретной стратегии шардинга данных. Его можно использовать в качестве дополнения к предлагаемому нами шаблону для реализации стратегии чтения и записи после внедрения описанного здесь шаблона.</p>

      <h2>4 Шардинг с помощью хэш-партиционирования</h2>

      <p>Целью паттерна масштабирования базы данных «Шардирование по хэш-партиционированию» является максимально равномерное распределение функциональной группы между узлами кластера с использованием метода шардинга. Желаемым результатом является равномерное распределение нагрузки, генерируемой клиентскими запросами, между серверами баз данных.</p>

      <h3>4.1 Контекст</h3>

      <p>Методы масштабирования используются для повышения производительности систем баз данных. Архитектура «ведущий/ведомый» обеспечивает масштабируемость по чтению, но не слишком полезна для приложений с высокой интенсивностью записи. Для достижения общей масштабируемости чтения и записи следует использовать метод шардинга. Однако системы без общего доступа масштабируются только в том случае, если объекты данных распределены по узлам системы таким образом, чтобы обеспечить балансировку нагрузки (Stonebraker и Cattell, 2011).</p>
      <p>Кластеры, использующие метод шардинга для разделения данных, распределяют их между несколькими серверами баз данных, обеспечивая балансировку запросов и запросов на обновление. С другой стороны, неэффективное распределение может привести к двум проблемам: точкам концентрации, содержащим наиболее востребованные реестры, и серверам, на которых сосредоточено большинство запросов на обновление. Эти точки концентрации, известные как «горячие точки» (Stonebraker и Cattell, 2011), могут представлять собой набор данных, хранящийся только на одном сервере, или наборы данных, распределенные между несколькими серверами.</p>
      <p>Например, предположим, что таблица, содержащая поле даты, хронологически распределена между тремя серверами баз данных: A, B и C. Сервер A отвечает за хранение самых старых данных, сервер B — за хранение промежуточных данных, а сервер C — за хранение самых последних данных. Если клиентское приложение постоянно генерирует новые данные, сервер C будет получать большую часть запросов на обновление. Кроме того, существует высокая вероятность того, что сервер C получит большую часть запросов, поскольку пользователи приложения, как правило, больше интересуются актуальной информацией. В этом случае попытка распределить нагрузку между тремя серверами баз данных путем сегментирования данных с использованием стратегии сегментирования по диапазону завершится неудачей.</p>

      <h3>4.2 Задача</h3>

      <p>Как распределить данные, избегая создания горячих точек, чтобы получить сегментированный кластер, который равномерно распределяет нагрузку по запросам между узлами?</p>

      <h3>4.3 Силы</h3>

      <p>При использовании шардинга разделение данных между узлами для предотвращения «горячих точек» — нетривиальная задача. Выбор подходящей стратегии шардинга должен зависеть от модели доступа к данным приложения. В большинстве случаев неправильный выбор стратегии шардинга снижает производительность системы.</p>
      <p>Избыточный трафик может возникать в системах баз данных, где размещение данных не было тщательно выбрано разработчиком (Zilio et al., 1994). При использовании стратегии шардинга по круговой схеме данные распределяются без учёта их атрибутов. Реестры, которые обычно агрегируются для формирования результата запроса, могут быть разбросаны по узлам, что приводит к увеличению трафика данных.</p>
      <p>Естественно рассматривать распределение данных на основе естественных ключей разбиения, таких как поля даты. Поэтому очевидным выбором будет стратегия разбиения по диапазонам. Однако в приложениях, в которых пользователи интересуются только актуальной информацией, разбиение по диапазонам может приводить к появлению «горячих точек», как в примере, показанном в конце раздела 4.1.</p>
      <p>Помимо правильной балансировки нагрузки между серверами баз данных в кластере, стратегия разбиения на разделы не должна приводить к значительным накладным расходам при определении того, в каком узле должен находиться реестр.</p>

      <h3>4.4 Решение</h3>

      <p>Хеш-разбиение может использоваться для равномерного распределения нагрузки запросов между узлами распределенной системы баз данных. В качестве ключа разбиения необходимо выбрать поле, значения которого принадлежат группе реестров. При выборе разбиения следует учитывать, что реестры, к которым часто обращаются совместно, будут использовать одно и то же значение ключа разбиения.</p>
      <p>Запросы, требующие данных с одинаковым значением ключа разбиения, будут направлены на один и тот же узел. Следовательно, когда два или более запросов запрашивают данные с разными значениями ключа разбиения, они будут направлены на разные узлы. То же самое происходит и при сохранении новых данных в сегментированном кластере. К значению ключа разбиения в новом реестре применяется хеш-функция. Результат определяет, в каком узле будут храниться данные. Следовательно, если два новых реестра имеют разные значения ключа разбиения, они будут храниться в разных узлах кластера.</p>
      <p>После выбора поля ключа разбиения можно создать индекс на основе другого поля для упорядочивания реестров с одинаковым значением ключа разбиения. При наличии этого вторичного индекса можно упорядочить результаты запросов, ищущих реестры с одинаковым значением ключа разбиения.</p>

      <h3>4.5 Результаты</h3>

      <p>Размещение данных крайне важно в параллельных системах баз данных, не требующих совместного использования ресурсов. Оно должно обеспечивать параллелизм и минимизировать коммуникационные издержки (Zilio et al., 1994). Системы, агрегирующие необходимую информацию только в одном реестре, лучше всего подходят для такого подхода, поскольку он минимизирует сетевой трафик. Поэтому важно максимально избегать многошардных операций, включая запросы, направленные на несколько шардов, а также многошардных обновлений, требующих свойств ACID (Stonebraker and Cattell, 2011). Таким образом, шардирование данных между узлами кластера лучше всего подходит для приложений, не требующих соединений между таблицами базы данных.</p>

      <div class="article-picture">
        <img src="images/ar20_2.webp" style="max-width:40%;">
        <p>Рисунок 3 - Таблица журнала транзакций, разделенная по хэш-ключу.</p>
      </div>
      
      <p>Если хеш-партиционирование необходимо полностью реализовать на уровне доступа к данным приложения, необходимо выбрать алгоритм и хеш-функцию для реализации метода хеш-партиционирования. Например, MD5 (Rivest, 1992) может быть реализацией хеш-функции, а алгоритм Consistent Hashing (Karger et al., 1997) может использоваться для распределения и поиска данных в кластере. Инструменты, реализующие этот шаблон, такие как некоторые хранилища данных NoSQL, изначально поддерживающие шардинг, и некоторые фреймворки персистентности, уже имеют реализованный алгоритм.</p>
      <p>Даже если используемое хранилище данных или фреймворк персистентности уже реализуют шаблон, выбор правильного хеш-ключа для партиционирования является задачей разработчика базы данных. Выбор правильного ключа партиционирования очень важен при использовании метода хеш-партиционирования. Разработчик базы данных должен выбрать правильный ключ партиционирования, чтобы равномерно распределить нагрузку между разделами. Например, если таблица содержит очень небольшое количество часто используемых реестров (даже один), трафик запросов будет сосредоточен на небольшом количестве разделов. Для достижения сбалансированной нагрузки хеш-ключ разбиения должен содержать большое количество различных значений, которые запрашиваются достаточно равномерно, максимально случайным образом. В таблице 1 показаны распространённые хеш-ключи разбиения и их эффективность.</p>

      <h3>4.6 Дальше</h3>

      <p>Облачные хранилища данных предоставляют необходимую инфраструктуру для масштабирования с меньшими затратами и упрощенным управлением. Однако большинство облачных реляционных баз данных не реализуют шаблон шардинга по хэш-партиционированию. Более того, они не поддерживают шардинг изначально. В таких случаях функциональность хранилища данных может быть расширена путем реализации шаблона на уровне доступа к данным приложения. Штраух и др. (Strauch et al., 2012) описывают шаблон «Локальный маршрутизатор на основе шардинга», который дополняет шаблон, описанный в этой статье. Шаблон «Локальный маршрутизатор на основе шардинга» предлагает дополнительный уровень, развернутый в облаке, отвечающий за реализацию шардинга в облачных хранилищах данных, которые изначально не поддерживают шардинг. Шаблон «Локальный маршрутизатор на основе шардинга» не предполагает какой-либо стратегии шардинга.</p>

      <h3>4.7 Сайдбары</h3>

      <p>Существуют хранилища данных NoSQL, такие как MongoDB (Liu et al., 2012) и DynamoDB (DeCandia et al., 2007), которые реализуют шаблон Sharding by Hash Partitioning. Эти хранилища данных можно использовать, если шаблон доступа приложения не требует соединений между различными таблицами и требует масштабируемости, обеспечиваемой шардингом данных, и балансировки рабочей нагрузки, обеспечиваемой хэш-партиционированием. То есть, если приложение выиграет от шаблона Sharding by Hash Partitioning и не нуждается в ограничениях отношений, предлагаемых реляционными базами данных, можно использовать упомянутые хранилища данных. В статье (DeCandia et al., 2007) описывается алгоритм хэш-партиционирования, используемый DynamoDB. Он является разновидностью алгоритма Consistent Hashing (Karger et al., 1997) и может быть использован в качестве справочного материала для реализации шаблона Sharding by Hash Partitioning при разработке фреймворка или на уровне доступа к данным приложения.</p>
      <p>Реляционные базы данных поддерживают шардинг в архитектуре без совместного использования ресурсов (really nothing shared Architecture), но те, которые поддерживают, как правило, сложнее в обслуживании. Если приложению требуется шардировать данные с помощью хэш-партиционирования, но используемая реляционная база данных не предоставляет такую ​​возможность, можно использовать фреймворк, реализующий шаблон шардинга по хэш-ключу. EclipseLink реализует политику шардинга данных по хэш-ключу и может предоставлять эту возможность реляционным базам данных, не поддерживающим шардинг. В качестве альтернативы, его можно использовать, если разработчики не знают, как настроить базы данных с поддержкой шардинга.</p>
      <p>В локальных приложениях, хранящих данные в облаке, если шаблон шардинга по хэш-партиционированию должен быть реализован на уровне доступа к данным, это должно быть сделано на стороне облака, чтобы избежать сетевых задержек при запросе более чем к одному узлу (Strauch et al., 2012).</p>

      <h3>4.8 Пример</h3>

      <p>Для лучшего понимания шаблона шардинга по хэш-разбиению в качестве примера будет использована система, которая регистрирует каждую транзакцию, совершаемую клиентами банка. В одной таблице хранятся все реестры журнала транзакций. В каждом реестре есть поле, описывающее любую распространённую банковскую транзакцию, которую может выполнить клиент банка, например, снятие, внесение или перевод. Как и ожидалось, в таблице есть поле с датой транзакции.</p>
      <p>Со временем таблица становится очень большой. ИТ-специалисты решают распределить данные таблицы по узлам кластера для повышения производительности и масштабируемости. Создаётся кластер, состоящий из трёх серверов баз данных. В первой попытке таблица секционируется хронологически, то есть настраивается секционирование по диапазону, основанное на дате транзакции. Сервер A хранит самые старые транзакции, а сервер C — самые последние (рисунок 2). Такая схема секционирования создаёт «горячие точки». Все новые реестры журналов транзакций хранятся на сервере C, и большинство клиентов банка просматривают свои последние транзакции, которые также хранятся на сервере C.</p>
      <p>В этом случае рекомендуется использовать секционирование по хэш-ключу. ИТ-специалисты банка решают разделить таблицу журналов транзакций, используя идентификатор клиента в качестве ключа секционирования. Кроме того, они создают индекс на основе поля даты транзакции. Теперь результат хэш-функции, примененной к идентификатору клиента, определяет место хранения реестра транзакций (рис. 3). Благодаря большому количеству клиентов, данные, вероятностно, распределены более равномерно. Когда клиенты просматривают свои последние транзакции, запросы будут распределены по узлам кластера. Индекс, основанный на дате транзакции, будет поддерживать упорядоченность реестров журналов транзакций в результатах клиентского запроса.</p>

      <h2>5 ВЫВОДЫ</h2>

      <p>Шардинг данных, основанный на секционировании по хэш-ключу, идентифицированный и формализованный в данной работе как шаблон масштабируемости базы данных, эффективно обеспечивает масштабируемость чтения и записи, повышая производительность кластера базы данных. Однако шардинг данных с помощью секционирования по хэш-ключу не решает всех проблем масштабируемости базы данных. Поэтому он не рекомендуется для всех сценариев. Формальное описание решения в виде шаблона помогает в задаче сопоставления шардинга данных с помощью секционирования по хэш-ключу с рекомендуемым сценарием.</p>
      <p>В рамках дальнейшей работы мы планируем продолжить формализацию решений горизонтальной масштабируемости базы данных в виде шаблонов, чтобы создать каталог, содержащий список шаблонов масштабируемости базы данных, направленных на решение проблем масштабируемости.</p>

      <h2>Литература</h2>
      <ol>
        <li>Абрамсон И., Эбби М., Кори М. Дж., Малчер М. Oracle Database 11g. Руководство для начинающих [Oracle Database 11g. A Beginner’s Guide]. Oracle Press, 2009.</li>
        <li>Адлер Б. Создание масштабируемых приложений в облаке. Референсная архитектура и лучшие практики [Building scalable applications in the cloud. Reference architecture and best practices]. 2011.</li>
        <li>Бойча А., Радулеску Ф., Агапин Л. И. Сравнение MongoDB и Oracle [Mongodb vs oracle – database comparison] // Proceedings of the 2012 Third International Conference on Emerging Intelligent Data and Web Technologies. 2012. С. 330–335.</li>
        <li>Коннолли Т. М., Бегг К. Е. Системы баз данных. Практический подход к проектированию, реализации и управлению [DATABASE SYSTEMS. A Practical Approach to Design, Implementation, and Management]. 4-е изд. Addison-Wesley, 2005.</li>
        <li>Декандиа Дж., Хасторун Д., Джампани М. и др. Dynamo: высокодоступное хранилище типа ключ-значение от Amazon [Dynamo: amazon’s highly available key-value store] // Proceedings of Twenty-first ACM SIGOPS Symposium on Operating Systems Principles (SOSP ’07). Нью-Йорк : ACM, 2007. С. 205–220.</li>
        <li>ДеВитт Д., Грей Дж. Параллельные системы баз данных: будущее высокопроизводительных СУБД [Parallel database systems: The future of high performance database systems] // Communications of the ACM. 1992. Т. 35, № 6. С. 85–98.</li>
        <li>Эссаар Э. Проектирование и реализация баз данных на основе паттернов [On pattern-based database design and implementation] // Proceedings of the 2008 International Conference on Software Engineering Research, Management and Applications. 2008. С. 235–242.</li>
        <li>Элмасри Р., Навате Ш. Б. Основы систем баз данных [Fundamentals of Database Systems]. 6-е изд. Addison-Wesley, 2011.</li>
        <li>Фелинг К., Лейманн Ф., Реттер Р. и др. Язык архитектурных паттернов облачных приложений [An architectural pattern language of cloud-based applications] // Proceedings of the 18th Conference on Pattern Languages of Programs (PLoP ’11). Нью-Йорк : ACM, 2011. № 2. С. 1–11.</li>
        <li>Фаулер М., Райс Д., Фёммель М. и др. Паттерны корпоративных приложений [Patterns of Enterprise Application Architecture]. Addison-Wesley, 2002.</li>
        <li>Гамма Э., Хелм Р., Джонсон Р., Влиссидес Дж. Приёмы объектно-ориентированного проектирования. Паттерны проектирования [Design Patterns. Elements of Reusable Object-Oriented Software]. 1-е изд. Addison-Wesley, 1994.</li>
        <li>Го Дж. Проектирование масштабируемой стратегии партиционирования для Azure Table Storage [Designing a scalable partitioning strategy for azure table storage] : электронный ресурс. Microsoft Docs, 2014. URL: http://msdn.microsoft.com/en-us/library/azure/hh508997.aspx (дата обращения: 20.10.2025).</li>
        <li>Хафиз М. Коллекция паттернов обеспечения конфиденциальности [A collection of privacy design patterns] // Proceedings of the 2006 Conference on Pattern Languages of Programs (PLoP ’06). Нью-Йорк : ACM, 2006. № 7. С. 1–7.</li>
        <li>Хопе Г., Вулф Б. Паттерны интеграции корпоративных приложений [Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions]. 1-е изд. Addison-Wesley, 2003.</li>
        <li>Калотра М., Каур К. Анализ производительности повторно используемых программных систем [Performance analysis of reusable software systems] // 2014 5th International Conference on Confluence The Next Generation Information Technology Summit. 2014. С. 773–778.</li>
        <li>Каргер Д., Леман Э., Лейтон Т. и др. Согласованное хеширование и случайные деревья: распределённые протоколы кэширования для устранения горячих точек во Всемирной паутине [Consistent hashing and random trees: Distributed caching protocols for relieving hot spots on the world wide web] // Proceedings of the Twenty-ninth Annual ACM Symposium on Theory of Computing (STOC ’97). Нью-Йорк : ACM, 1997. С. 654–663.</li>
        <li>Лю Ю., Ван Ю., Цзинь Ю. Исследование улучшения автоматического шардирования MongoDB в облачной среде [Research on the improvement of mongodb auto-sharding in cloud environment] // Proceedings of the 7th International Conference on Computer Science and Education. 2012. С. 851–854.</li>
        <li>Паллманн Д. Паттерны проектирования Windows Azure [Windows azure design patterns] : электронный ресурс. 2011. URL: http://neudesic.blob.core.windows.net/webpatterns/index.html (дата обращения: 20.10.2025).</li>
        <li>Ривест Р. Алгоритм хеш-суммы сообщения MD5 [The md5 message-digest algorithm]. IETF RFC 1321, 1992.</li>
        <li>Садалаге П. Дж., Фаулер М. NoSQL вкратце. Краткое руководство по миру полиглотной персистентности [NoSQL Distilled. A Brief Guide to the Emerging World of Polyglot Persistence]. 1-е изд. Addison-Wesley, 2013.</li>
        <li>Шумахер М. Паттерны безопасности и стандарты безопасности — с избранными паттернами анонимности и конфиденциальности [Security patterns and security standards – with selected security patterns for anonymity and privacy] // European Conference on Pattern Languages of Programs. 2003.</li>
        <li>Шумахер М., Фернандес-Бульони Э., Хайбертсон Д. и др. Паттерны безопасности: интеграция безопасности и системной инженерии [Security Patterns: Integrating Security and Systems Engineering]. Wiley, 2006.</li>
        <li>Стоунбрейкер М., Каттелл Р. 10 правил масштабируемой производительности в хранилищах «простых операций» [10 rules for scalable performance in ‘simple operation’ datastores] // Communications of the ACM. 2011. Т. 54, № 6. С. 72–80.</li>
        <li>Штраух С., Андрикопулос В., Брайтенбюхер У. и др. Нефункциональные паттерны слоя данных для облачных приложений [Non-functional data layer patterns for cloud applications] // 2012 IEEE 4th International Conference on Cloud Computing Technology and Science. 2012. С. 601–605.</li>
        <li>Ву П., Инь К. Исследование применения технологии персистентности на основе Hibernate [Application research on a persistent technique based on hibernate] // International Conference on Computer Design and Applications. 2010. Т. 1. С. 629–631.</li>
        <li>Зилио Д. К., Джингран А., Падманабхан С. Выбор ключа партиционирования для параллельной СУБД типа shared-nothing [Partitioning key selection for a shared-nothing parallel database system] : технический отчёт. IBM Research Division, Yorktown Heights, NY, 1994.</li>

        <li>Фамилия И.О. Название источника [Электронный ресурс] // Издательство. -- Год. -- Режим доступа: <a href="https://example.com">https://example.com</a></li>
      </ol>
      
      <!-- Английская версия аннотации -->
      <div class="article-annotation">
        <p>Sharding by Hash Partitioning</p>
        <p><i>A Database Scalability Pattern to Achieve Evenly Sharded Database Clusters</i></p>
        <p><strong>With the beginning of the 21st century, web applications requirements dramatically increased in scale. Applications like social networks, ecommerce, and media sharing, started to generate lots of data traffic, and companies started to track this valuable data. The database systems responsible for storing all this information had to scale in order to handle the huge load. With the emergence of cloud computing, scaling out a database system has became an affordable solution, making data sharding a viable scalability option. But to benefit from data sharding, database designers have to identify the best manner to distribute data among the nodes of shared cluster. This paper discusses database sharding distribution models, specifically a technique known as hash partitioning. Our objective is to catalog in the format of a Database Scalability Pattern the best practice that consists in sharding the data among the nodes of a database cluster using the hash partitioning technique to nicely balance the load between the database servers. This way, we intend to make the mapping between the scenario and its solution publicly available, helping developers to identify when to adopt the pattern instead of other sharding techniques.</strong></p>
        <p><strong>Ключевые слова:</strong> Database Sharding, Hash Partitioning, Pattern, Scalability.</p>
      </div>
    </div>
  </div>
</main>

<!-- Подвал -->
<footer class="footer lynch-footer">
  <div class="container">
    <nav class="bottom-menu">
      <a href="../diss/index.html">Реферат</a>
      <a href="../science.html">Научные труды</a>
      <a href="../ind/index.html">Индивидуальный раздел</a>
    </nav>
  </div>
</footer>

<!-- Кнопка наверх -->
<button id="toTop">↑</button>

<script>
  const toTop = document.getElementById("toTop");
  window.addEventListener("scroll", () => {
    if (window.scrollY > 300) {
      toTop.classList.add("show");
    } else {
      toTop.classList.remove("show");
    }
  });
  toTop.addEventListener("click", () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
  });
</script>
</body>
</html>